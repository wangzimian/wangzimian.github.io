---
title: 'Reading Falcon Note'
date: 2021-08-22
permalink: /posts/2021/08/blog-post-4/
tags:
  - Falcon
  - MPC
  - Secure Comparison
---

诚实方占多数的恶意安全模型下Secure Deep Learning框架

**基本思想** [Falcon](https://arxiv.org/pdf/2004.02229.pdf)设计了一个三方安全计算的机器学习框架。三方主要包括<font color="dd0000">数据拥有者</font>(data holder, DH)，需要机器学习服务的<font color="dd0000">查询用户</font>(query users, Users)和提供机器学习服务的<font color="dd0000">计算服务器</font>(computing servers, Server). Falcon框架包括两个阶段：训练阶段和推导阶段。训练阶段由DH提供数据，Server计算出机器学习模型；推导阶段User向Server发出查询请求，Server提供一个训练模型。DH把数据用<font color="dd00dd">重秘密共享(Replicated secret sharing)</font>方式把数据分布到不同<font color="dd0000">3个服务器</font>上。三个服务器利用这些共享数据训练出各自不同神经网络模块，用户此时可以提交查询，并得到模型的秘密分块。用户通过重构这些秘密分块重构出完整的训练模型。这种方式的优点是，因为服务器只有秘密分块，因此DH的数据对三个服务器都是完全隐私的，Users的查询请求也对服务器也是保密的。Falcon使用<font color="dd0000">安全多方计算</font>设计协议。安全性满足恶意安全，如果一方是恶意腐败的(corruption)，协议能够保证有正确的输出或者终止协议的恶意行为，不会输出错误的结果。同时文章也是[开源的](https://github.com/snwagh/falcon-public.git)。同时文章也对不同的机器学习安全多方计算协议进行比较，如下图。
![falcon多方计算比较图](/images/falcon/falcon_mpcml_compare.png)
ABY3依赖于高效进gc计算非线性函数，不同于简单的模数计算。
**相关随机性** 文章利用用$$\text{PRF}$$(伪随机函数)设计两个基本的随机数生成器。$(3,3)$随机性，即各方随机生成$$\alpha_i$$，使得$$ \alpha_1 + \alpha_2 + \alpha_3 = 0 $$。$(2,3)$随机性，即各方随机生成$$(\alpha_i, \alpha_{i+1})$$，使得$$ \alpha_1 + \alpha_2 + \alpha_3 = 0 $$。给定一个$P_i$和$P_{i+1}$之间的随机密钥$k_i$，令$$ \mathsf{cnt}$$ 是每次调用后递增的计数器。
* * * * * * 
初始化: $P_i$选择一个随机种子$k_i$，并把它发送给$P_{i+1}$。
一般随机性：令$F$是一个PRNG(伪随机数生成器)
* $$ \alpha_i = F_{k_i}(\mathsf{cnt}) - F_{k_{i-1}}(\mathsf{cnt}),\; \mathsf{cnt}++ $$ 
* $$ (\alpha_i, \alpha_{i-1}) = (F_{k_i}(\mathsf{cnt}), F_{k_{i-1}}(\mathsf{cnt})),\; \mathsf{cnt}++ $$
截断数对：$$ [\![ r]\!], [\![ r^\prime]\!] = [\![ r / 2^d]\!]$$ 
**关联隐私比较随机性**：
(1) 随机取样比特$$[\![ b]\!]^2 $$
(2) 利用位插入$$[\![ b]\!]^2 \rightarrow [\![ b]\!]^p  $$
(3) 随机取值$m_1, \cdots, m_k \in \mathbb{Z}_p$
(4) 计算并公开$$ m^{p-1}_1, \cdots, m^{p-1}_k $$
(5) 移除为0，留下为1的值，设置一个大的$k$值，均摊开销提高效率，共计$$ \lceil \log_2 p \rceil $$轮。    
**关联封装函数随机性：**
(1) 随机取样比特$$[\![ r_i ]\!]^2, \; i \in [l] $$
(2) 执行位分解得到$$[\![ r_i ]\!]^L $$
(3) 执行位插入$$[\![ r_i ]\!]^2 \rightarrow [\![ r_i ]\!]^p  $$
(4) 利用全加器计算最终进位     
**关联ReLU随机性：**
(1) 随机取样比特$$[\![ b]\!]^2 $$
(2) 利用位插入$$[\![ b]\!]^2 \rightarrow [\![ b]\!]^L  $$
* * * * * * 
**线性操作** 令$a,b,c$是公共参数，$$ [\![ x ]\!]^m $$ 和 $$ [\![ y ]\!]^m $$是秘密共享，各方在本地计算
* $$ [\![ ax + by + c ]\!]^m := (ax_1 + by_1 + c, ax_2 + by_2, ax_3 + by_3) $$。         

**乘法** 要使两个秘密共享相乘$$ [\![ x ]\!]^m = (x_1, x_2, x_3) $$ 和 $$ [\![ y ]\!]^m = (y_1, y_2, y_3)$$
* 各方本地计算$$z_1 = x_1y_1+x_2y_1+x_1y_2, z_2 = x_2y_2+x_3y_2+x_2y_3, z_3 = x_3y_3+x_1y_3+x_3y_1$$
* 由$z_1, z_2, z_3$形成$(3,3)$门限共享$$ [\![ z=x \cdot y ]\!]^m $$
* 各方执行重共享协议，利用$(3,3)$随机性生成$(2,3)$门限共享，即第$i$方发送$$ \alpha_i + z_i$$ 给第$i-1$方，$\{\alpha_i \}$形成$(3,3)$零共享。     

**重构$$[\![ x ]\!]^m$$** 
* 半诚实模型中，每方发送一个环元素给下一方，即$P_i$ 发送共享$x_i$ 给$P_{i+1}$
* 恶意模型中，第$i$方发送共享$x_i$给$P_{i+1}$，再发送共享$x_{i+1}$给$P_{i-1}$，若两个值不同，则中止协议。此轮协议是单轮通信。

**秘密共享** 输入两个随机共享$$ [\![ x ]\!]^L $$ 和 $$ [\![ y ]\!]^L $$，一个随机比特$$ [\![ b ]\!]^2 $$，通过判断$ b = 0 \; \text{or} \; 1 $输出$ [\![ Z ]\!]^L = [\![ x ]\!]^L \; \text{or} \; [\![ y ]\!]^L $。
* 获取共享随机比特$$ [\![ c ]\!]^2 $$，预计算$$ [\![ c ]\!]^L $$
* 公布比特$$ (b \oplus c) = e $$，若$e = 1$，设置$$ [\![ d ]\!]^L = [\![ 1 - c ]\!]^L $$；若$e = 0$，设置$$ [\![ d ]\!]^L = [\![ c ]\!]^L $$
* 计算$$ [\![ z ]\!]^L = [\![ (y-x) \cdot d ]\!]^L + [\![ x ]\!]^L $$，其中用乘法协议计算$$[\![ (y-x) \cdot d ]\!]^L $$



